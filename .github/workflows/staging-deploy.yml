name: Infrastructure Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - prod
      deploy_type:
        description: 'Type of deployment'
        required: true
        default: 'terraform'
        type: choice
        options:
          - terraform
          - ansible
          - full
      confirm_deployment:
        description: 'Confirm deployment (type YES to confirm)'
        required: true
        type: string
        default: 'NO'
  pull_request:
    types: [closed]
    branches: [main, staging, prod]
    paths:
      - 'Terraform/**'
      - 'Ansible/**'
      - '.github/workflows/**'
  push:
    branches: [staging, prod]
    paths-ignore:
      - 'README.md'
      - 'docs/**'

permissions:
  contents: read
  secrets: read
  pull-requests: write
  issues: write
  id-token: write

env:
  MAX_RETRY_ATTEMPTS: 3
  AWS_REGION: us-east-1

jobs:
  pre_deployment_checks:
    name: "Pre-deployment Validation"
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.decision.outputs.should_deploy }}
    steps:
      - name: Validate Trigger Conditions
        id: decision
        run: |
          # Workflow dispatch validation
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "${{ github.event.inputs.confirm_deployment }}" != "YES" ]]; then
              echo "::error::Deployment not confirmed. Please set confirm_deployment to 'YES'"
              echo "should_deploy=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          # PR validation
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            if [[ "${{ github.event.pull_request.merged }}" != "true" ]]; then
              echo "::notice::PR not merged, skipping deployment"
              echo "should_deploy=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          echo "should_deploy=true" >> $GITHUB_OUTPUT

      - name: Environment Safety Check
        if: steps.decision.outputs.should_deploy == 'true'
        run: |
          if [[ "${{ github.event.inputs.environment }}" == "prod" || "${{ github.ref }}" == "refs/heads/prod" ]]; then
            echo "::warning::PRODUCTION DEPLOYMENT INITIATED"
            echo "::group::Production Safety Checklist"
            echo "1. Staging tests passed ✓"
            echo "2. Change review completed ✓"
            echo "3. Team notified ✓"
            echo "4. Maintenance window scheduled ✓"
            echo "5. Rollback plan prepared ✓"
            echo "::endgroup::"
            sleep 15  # Safety delay
          fi

      - name: Verify Secrets Availability
        if: steps.decision.outputs.should_deploy == 'true'
        env:
          REQUIRED_SECRETS: >-
            AWS_ACCESS_KEY_ID
            AWS_SECRET_ACCESS_KEY
            SSH_PUBLIC_KEY
        run: |
          for secret in ${REQUIRED_SECRETS}; do
            if [ -z "${{ secrets[secret] }}" ]; then
              echo "::error::Missing required secret: $secret"
              exit 1
            else
              echo "Secret $secret is available (first 3 chars: ${${{ secrets[secret] }:0:3}...)"
            fi
          done

  terraform_deployment:
    needs: pre_deployment_checks
    if: needs.pre_deployment_checks.outputs.should_deploy == 'true'
    name: "Terraform - ${{ github.event.inputs.environment || 'staging' }}"
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'staging' }}
    
    defaults:
      run:
        working-directory: Terraform/${{ github.event.inputs.environment || 'staging' }}

    env:
      TF_INPUT: false
      TF_IN_AUTOMATION: true
      TF_WORKSPACE: ${{ github.event.inputs.environment || 'staging' }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_IAM_ROLE }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform-version: 1.5.7
          terraform-workspace: ${{ env.TF_WORKSPACE }}

      - name: Initialize Terraform
        id: init
        run: |
          terraform init -backend-config="key=${{ env.TF_WORKSPACE }}.tfstate"
          terraform workspace select ${{ env.TF_WORKSPACE }} || \
            terraform workspace new ${{ env.TF_WORKSPACE }}

      - name: Terraform Format
        run: terraform fmt -recursive -check -diff

      - name: Terraform Validate
        run: terraform validate -no-color

      - name: Terraform Plan
        id: plan
        run: |
          terraform plan -detailed-exitcode -out=tfplan
          echo "plan_has_changes=$([ $? -eq 2 ] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Upload Plan Artifact
        if: steps.plan.outputs.plan_has_changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ env.TF_WORKSPACE }}
          path: Terraform/${{ env.TF_WORKSPACE }}/tfplan
          retention-days: 3

      - name: Approve Production Deployment
        if: env.TF_WORKSPACE == 'prod' && steps.plan.outputs.plan_has_changes == 'true'
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ github.token }}
          approvers: ${{ secrets.PROD_APPROVERS }}
          minimum-approvals: 1

      - name: Terraform Apply
        if: steps.plan.outputs.plan_has_changes == 'true'
        run: terraform apply -auto-approve tfplan

      - name: Export Outputs
        run: |
          terraform output -json > outputs.json
          echo "outputs=$(jq -c . outputs.json)" >> $GITHUB_OUTPUT
          echo "::set-output name=outputs::$(jq -c . outputs.json)"

      - name: Upload Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs-${{ env.TF_WORKSPACE }}
          path: outputs.json

  ansible_configuration:
    needs: terraform_deployment
    if: |
      needs.terraform_deployment.result == 'success' &&
      (github.event.inputs.deploy_type == 'ansible' || 
       github.event.inputs.deploy_type == 'full' ||
       github.event_name == 'push')
    name: "Ansible - ${{ github.event.inputs.environment || 'staging' }}"
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'staging' }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs-${{ github.event.inputs.environment || 'staging' }}
          path: ansible/inventory/

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible==9.1.0 boto3==1.28.0

      - name: Configure Dynamic Inventory
        run: |
          jq -r '.instance_ips.value[]' ansible/inventory/outputs.json > ansible/inventory/${{ github.event.inputs.environment || 'staging' }}
          echo "[all]" >> ansible/inventory/${{ github.event.inputs.environment || 'staging' }}
          jq -r '.instance_ips.value[]' ansible/inventory/outputs.json >> ansible/inventory/${{ github.event.inputs.environment || 'staging' }}

      - name: Run Ansible Playbook
        working-directory: ansible
        env:
          ANSIBLE_FORCE_COLOR: 1
          ANSIBLE_HOST_KEY_CHECKING: false
        run: |
          ansible-playbook \
            -i inventory/${{ github.event.inputs.environment || 'staging' }} \
            site.yml \
            --extra-vars "env=${{ github.event.inputs.environment || 'staging' }}"

  notifications:
    name: "Deployment Notifications"
    needs: [terraform_deployment, ansible_configuration]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Determine Status
        id: status
        run: |
          if [[ "${{ needs.terraform_deployment.result }}" == "success" && 
                ("${{ needs.ansible_configuration.result }}" == "success" || 
                 "${{ needs.ansible_configuration.result }}" == "skipped") ]]; then
            echo "result=success" >> $GITHUB_OUTPUT
            echo "message=✅ Deployment completed successfully" >> $GITHUB_OUTPUT
          else
            echo "result=failure" >> $GITHUB_OUTPUT
            echo "message=❌ Deployment failed" >> $GITHUB_OUTPUT
          fi

      - name: Slack Notification
        if: ${{ secrets.SLACK_WEBHOOK_URL }}
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": "${{ steps.status.outputs.message }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*${{ github.workflow }}* - ${{ github.event.inputs.environment || 'staging' }}\n${{ steps.status.outputs.message }}"
                  }
                },
                {
                  "type": "divider"
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Triggered by:*\n${{ github.actor }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Commit:*\n<https://github.com/${{ github.repository }}/commit/${{ github.sha }}|${GITHUB_SHA:0:7}>"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
